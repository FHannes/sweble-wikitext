/**
 * Copyright 2011 The Open Source Research Group,
 *                University of Erlangen-NÃ¼rnberg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Lists
 * -----
 *
 *   Grammar:
 *     - ( [*#:]+ ';'? | ';' ) ListItemContentStar
 *
 */

module org.sweble.wikitext.parser.parser.List;

import org.sweble.wikitext.parser.parser.Content;
import org.sweble.wikitext.parser.parser.State;
import org.sweble.wikitext.parser.parser.Whitespace;




// -- Body ---------------------------------------------------------------------

header
{
  import java.util.Vector;
}

body
{
  public static enum ListType
  {
    DEFINITION,
    ITEMIZATION,
    ENUMERATION,
  }

  public static class ListNode
  {
    public ListType type;

    public WtContentNodeMarkTwo node;

    public ListNode(ListType type, WtContentNodeMarkTwo node)
    {
      this.type = type;
      this.node = node;
    }

    public boolean comparePrefix(char ch)
    {
      switch (type)
      {
        case DEFINITION:
          return (ch == ';' || ch == ':');
        case ENUMERATION:
          return (ch == '#');
        case ITEMIZATION:
          return (ch == '*');
        default:
          return false;
      }
    }
  }

  private void pushNewList(Vector<ListNode> listStack, char ch, boolean createItem)
  {
    ListNode node = null;
    switch (ch)
    {
      case '*':
        node = new ListNode(ListType.ITEMIZATION, new WtUnorderedList());
        break;
      case '#':
        node = new ListNode(ListType.ENUMERATION, new WtOrderedList());
        break;
      case ':':
      case ';':
        node = new ListNode(ListType.DEFINITION, new WtDefinitionList());
        break;
    }

    if (!listStack.isEmpty())
      getLastItemContent(listStack).add(node.node);

    listStack.add(node);

    if (createItem)
    {
      // FIXME: Issue warning!
      pushNewListItem(listStack, ch, new WtNodeList());
    }
  }

  private WtNode pushNewListItem(Vector<ListNode> listStack, char ch, WtNodeList content)
  {
    WtNode n = null;
    switch (ch)
    {
      case '*':
        n = new WtListItem(content);
        break;
      case '#':
        n = new WtListItem(content);
        break;
      case ':':
        n = new WtDefinitionListDef(content);
        break;
      case ';':
        n = new WtDefinitionListTerm(content);
        break;
    }
    getCurrentListContent(listStack).add(n);
    return n;
  }

  private WtNodeList getCurrentListContent(Vector<ListNode> listStack)
  {
    return listStack.lastElement().node;
  }

  private WtNodeList getLastItemContent(Vector<ListNode> listStack)
  {
    WtNodeList items = getCurrentListContent(listStack);
    return (WtContentNodeMarkTwo) items.get(items.size() - 1);
  }

  private WtNodeList makeList(WtForeignNode first, Pair<WtForeignNode> tail)
  {
    Vector<ListNode> listStack = new Vector<ListNode>();

    WtNodeList items = new WtNodeList();

    WtRtData lastItem = processListItem(listStack, items, first);

    for (Pair<WtForeignNode> i = tail; !i.isEmpty(); i = i.tail())
    {
      WtForeignNode item = i.head();

      if (lastItem != null)
        lastItem.setField(1, item.getForeign(1, String.class));

      lastItem = processListItem(listStack, items, item);
    }

    return items;
  }

  private WtRtData processListItem(Vector<ListNode> listStack, WtNodeList items, WtForeignNode p)
  {
    String prefix = p.getForeign(3, String.class);

    int j;
    for (j = 0; j < prefix.length() && j < listStack.size(); ++j)
    {
      if (!listStack.get(j).comparePrefix(prefix.charAt(j)))
        break;
    }

    // pop closed list levels
    listStack.setSize(j);

    boolean addRoot = (j == 0);

    int last = prefix.length() - 1;

    // open new list levels
    for (; j < prefix.length(); ++j)
      pushNewList(listStack, prefix.charAt(j), j < last);

    // push the actual list item
    WtNode item = pushNewListItem(
        listStack,
        prefix.charAt(last),
        new WtNodeList(p.getForeign(0, WtNodeList.class)));

    WtRtData rtd = null;
    if (isGatherRtData())
    {
      rtd = new WtRtData(2, p.getForeign(2, WtNode.class), prefix, SEP);
      item.setRtd(rtd);
    }

    if (addRoot)
      items.add(listStack.firstElement().node);

    return rtd;
  }
}




// -- List --[ State Aware Memoization ]-------------------------------------

noinline transient WtNode List =
 ^{
    StateAwareResult r = (StateAwareResult) pListMemoized(yyBase);
    final WikitextParserContext context = getContext();
    Result yyResult = r.getResult(context);
    if (yyResult == null)
      yyResult = r.setResult(context, pListTransient(yyBase));
    if (returnTrue(r))
      return yyResult;
  }
;

noinline memoized WtNode ListMemoized =
 ^{
    Result yyResult = new StateAwareResult("List", getContext(), pListTransient(yyBase));
    if (returnTrue(yyResult))
      return yyResult;
  }
;




// -- List ------------------------------------------------------------------

noinline transient WtNode ListTransient =
  &{ accept(ParserAtoms.LIST) } first:ListItem tail:( &slEol ListItem )*
  {
    yyValue = makeList(first, tail);
  }
;

private noinline transient WtForeignNode ListItem =
  rt0:pEol? rt1:pTpStar prefix:ListPrefix content:ListItemContentStar
  {
    // TODO: Support "; term : def" on a single line
    yyValue = WtForeignNode.from(content, rt0, rt1, prefix);
  }
;

private inline String ListPrefix =
    prefix:ListPrefixStr semicolon:';'?
    {
      yyValue = (semicolon != null) ? prefix + ';' : prefix;
    }
  / ';'
    {
      yyValue = ";";
    }
;

private transient String ListPrefixStr =
  [*#:]+
;

private inline stateful WtNodeList ListItemContentStar =
  {
    enter(ParserScopes.LIST_ITEM);
  }
  InlineContentStar
;




// -- End of file -------------------------------------------------------------
