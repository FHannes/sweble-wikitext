/**
 * Copyright 2011 The Open Source Research Group,
 *                University of Erlangen-NÃ¼rnberg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Templates
 * ---------
 *   - Arguments are parsed in the same way for transclusions and template
 *     parameters, although template parameters only take one default value.
 *     That's ok since MediaWiki too treats arguments for both the same way and
 *     only takes the value after the first pipe as default value for the
 *     template parameter.
 *
 */

module org.sweble.wikitext.parser.preprocessor.Template;

import org.sweble.wikitext.parser.utils.Whitespace;

import org.sweble.wikitext.parser.preprocessor.State;
import org.sweble.wikitext.parser.preprocessor.ContentTemplateArgumentName;
import org.sweble.wikitext.parser.preprocessor.ContentTemplateArgumentValue;
import org.sweble.wikitext.parser.preprocessor.ContentTemplateName;




// -- Header / Body / Footer ---------------------------------------------------

body
{
  @SuppressWarnings("serial")
  private static final class TemplateTailPart2
      extends
          WtTempNode
  {
    WtName name;
    WtTemplateArguments args;
  }
}




// -- Article ------------------------------------------------------------------

stateful WtNode Template =
    eol:pEol? braces:Braces1Plus
    {
      /* ALL PRODUCTIONS THAT DEPEND ON THE NUMBER OF BRANCES MUST
       * BE TRANSIENT! THAT'S ALSO TRUE FOR PRODUCTIONS WHICH USE
       * PRODUCTIONS THAT DEPEND ON THE BRACE COUNT
       */
      getState().setTemplateBraces(braces.length());
    }
    yyValue:TemplateTail
    {
      if (eol != null)
      {
        WtNode tmpl = yyValue;
        if (yyValue instanceof WtNodeList)
        {
          WtNodeList list = (WtNodeList) yyValue;
          tmpl = list.get(list.size() - 1);
        }
        if (yyValue instanceof WtTemplate)
          ((WtTemplate) yyValue).setPrecededByNewline(true);
        else
          ((WtTemplateParameter) yyValue).setPrecededByNewline(true);
        yyValue = list(new WtText(eol), yyValue);
      }
    }
  / eol:pEol? braces:Braces1Plus
    {
      yyValue = new WtText((eol != null) ? eol + braces : braces);
    }
;

private transient String Braces1Plus = "{" "{"+ ;

/* Template tail generating one template/parameter or two nested template
 *
 * Multiple opening braces without interjacent spaces can generate at most two
 * nested templates. This production tries to identify these nested templates.
 *
 * ITS VITALLY IMPORTANT TO NOT SPLIT THIS PRODUCTION INTO TWO CHOICES
 * where the first choice expects two TemplateTailPart's and the second
 * choice is satisfied with only one TemplateTailPart. The reason:
 * If the first choice fails, the template brace count has already changed!
 * If the Rats! parser generator does not collapse the common prefix, the
 * second choice will try to parse the TemplateTailPart again, but this time
 * with the wrong brace count!
 */
private transient WtNode TemplateTail =
  inner:TemplateTailPart outer:TemplateTailPart?
  {
    if (outer != null)
    {
      // insert inner template in front of the name of the outer template
      ((WtNodeList) ((WtNode) outer).get(0)).add(0, inner);
      yyValue = outer;
    }
    else
    {
      yyValue = inner;
    }

    // if more braces were openend than can be consumed by at most two
    // templates/parameters we have to restore the remaining braces in front
    // of the recognized templates.
    int stillOpen = getState().getTemplateBraces();
    if (stillOpen > 0)
    {
      yyValue = list(
        new WtText(StringUtils.strrep('{', stillOpen)),
        yyValue);

      getState().setTemplateBraces(0);
    }
  }
;

/* Template tail part generating either a Template or a Parameter
 * Eats 2 or 3 closing braces
 * ... [name] [arguments] }}}?
 */
private transient WtNode TemplateTailPart =
    content:TemplateTailPart2 TemplateTailPart3
    {
      WtTemplateArguments args = content.args;

      WtTemplateArguments garbage = null;
      WtValue defaultValue = null;
      if (args.size() > 0)
      {
        WtTemplateArgument arg0 = (WtTemplateArgument) args.get(0);
        WtNodeList arg0Value = list();
        if (arg0.hasName()) {
          arg0Value.addAll(arg0.getName());
          arg0Value.add(new WtText("="));
        }
        arg0Value.add(arg0.getValue());
        defaultValue = new WtValueImpl(arg0Value);
        if (args.size() > 1)
          garbage = new WtTemplateArguments(list(args.subList(1, args.size())));
      }

      yyValue = setRtd(
        new WtTemplateParameter(content.name, defaultValue, garbage),
        "{{{", SEP, SEP, SEP, "}}}");

      getState().eatTemplateBraces(3);
    }
  / content:TemplateTailPart2
    {
      // content = (name, args)
      yyValue = setRtd(
	new WtTemplate(content.name, content.args),
        "{{", SEP, SEP, "}}");

      getState().eatTemplateBraces(2);
    }
;

/* Template tail part.
 * Eats 2 closing braces
 * ... [name] [arguments] }}
 *
 * It MUST BE TempalteName>Star<
 * Example:
 *   {{{{{param}}<no content here for example>}}}
 */

private transient TemplateTailPart2 TemplateTailPart2 =
  &{ hasAtLeastTemplateBraces(2) } name:TemplateNameStar args:TemplateArgumentStar "}}"
  {
    yyValue = new TemplateTailPart2();
    yyValue.name = new WtNameImpl(name);
    yyValue.args = new WtTemplateArguments(args);
  }
;

/* Template tail part.
 * Eats the third closing brace
 * ... }
 */

private transient void TemplateTailPart3 =
  &{ hasAtLeastTemplateBraces(3) } '}'
;




// -- Template/Parameter arguments ---------------------------------------------

private transient WtNode TemplateArgumentChoice =
    parameter:TemplateArgumentNamePlus '=' value:TemplateArgumentValueStar
    {
      yyValue = setRtd(
        new WtTemplateArgument(new WtNameImpl(parameter), new WtValueImpl(value)),
        '|', SEP, '=', SEP);
    }
  / value:TemplateArgumentValueStar
    {
      yyValue = setRtd(
        new WtTemplateArgument(new WtValueImpl(value)),
        '|', SEP, SEP);
    }
;

private transient WtNodeList TemplateArgumentStar =
  args:( void:'|' TemplateArgumentChoice )*
  {
    yyValue = list(args);
  }
;




// -- End of file --------------------------------------------------------------
