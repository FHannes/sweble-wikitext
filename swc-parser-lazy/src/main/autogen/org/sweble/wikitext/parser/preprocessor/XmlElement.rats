/**
 * Copyright 2011 The Open Source Research Group,
 *                University of Erlangen-NÃ¼rnberg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * XML Elements
 * ------------
 *
 *   - NONE OF THESE XML ELEMENTS CAN NEST!
 *   - <onlyinclude> tags prevent parsing of the content AROUND them. That's
 *     why these tags have to be handled specially by the module
 *     ContentOnlyInclude and not here.
 *   - <includeonly> tags also behave specially:
 *     - The wikitext is marked for inclusion only: The content of the
 *       <inclueonly> element is parsed by the preprocessor and the scope of
 *       the tag is ignored. Start and end tags are simply ignored.
 *     - The wikitext is marked for direct viewing: The complete element with
 *       its content is ignored. No parsing of the content is done by the
 *       preprocessor.
 *   - <noinclude> tags also behave specially: They are treated the other way
 *     round compared to the <includeonly> tags.
 *   - All other tags that are recognized as tag extensions are handled
 *     specially in that their content is not parsed by the preprocessor and
 *     they can NOT nest.
 *
 */

module org.sweble.wikitext.parser.preprocessor.XmlElement;

import org.sweble.wikitext.parser.utils.Roundtrip;
import org.sweble.wikitext.parser.utils.Whitespace as Whitespace;
import org.sweble.wikitext.parser.utils.XmlName;
import org.sweble.wikitext.parser.utils.XmlAttribute(Whitespace);




// -- XML Element --------------------------------------------------------------

WtNode XmlElement =
  '<' yyValue:
  ( "!--" yyValue:XmlComment
  / '/'   yyValue:IgnoredClosingTag
  /       IgnoredOpeningTag
  /       IgnoredElements
  /       TagExtension
  /       Greater
  )
;

private inline WtText Greater =
  !ValidClosingTag
  {
    yyValue = new WtText("<");
  }
;




// -- XML Comment --------------------------------------------------------------

//
// When a comment is preceded AND followed by newlines (ignoring spaces) the
// spaces in front and after the comment are removed as well as the newline
// following the comment. The newline in front of the comment IS NOT TOUCHED!
//
// If a comment is not enclosed in newlines (ignoring spaces) then only the
// comment itself is consumed.
//
transient WtNode XmlCommentTrimmed =
    eol1:pEol prefix:PureSpaceStar "<!--" content:XmlCommentContent "-->" suffix:PureSpaceStar eol2:pEol
    {
      WtXmlComment c = setRtd(new WtXmlComment(content, prefix, suffix + eol2), prefix, "<!--", content, "-->", suffix, eol2);

      yyValue = new WtNodeList(new WtText(eol1), c);
    }
  / eol1:pEol prefix:PureSpaceStar "<!--" content:XmlCommentContent "-->"
    {
      WtXmlComment c = setRtd(new WtXmlComment(content), "<!--", content, "-->");

      yyValue = new WtNodeList(new WtText(eol1 + prefix), c);
    }
  / eol1:pEol prefix:PureSpaceStar "<!--" content:XmlCommentContent
    {
      WtXmlComment c = setRtd(new WtXmlComment(content), "<!--", content);

      yyValue = new WtNodeList(new WtText(eol1 + prefix), c);
    }
;

private transient String PureSpaceStar =
  ' '*
;

private transient WtXmlComment XmlComment =
    content:XmlCommentContent "-->"
    {
      yyValue = setRtd(new WtXmlComment(content), "<!--" + content + "-->");
    }
  / content:XmlCommentContent Eof
    {
      yyValue = setRtd(new WtXmlComment(content), "<!--" + content);
    }
;

private transient String XmlCommentContent =
  ( !"-->" _ )*
;




// -- Ignored opening, closing tags --------------------------------------------

private transient WtNode IgnoredClosingTag =
  name:IgnoredTagName garbage:IgnoredTagGarbage '>'
  {
    String content = "</" + name + garbage + ">";

    yyValue = setRtd(new WtIgnored(content), content);
  }
;

private transient WtNode IgnoredOpeningTag =
  name:IgnoredTagName garbage:IgnoredTagGarbage '>'
  {
    String content = "<" + name + garbage + ">";

    yyValue = setRtd(new WtIgnored(content), content);
  }
;

private inline String IgnoredTagName =
  yyValue:TagName &{ isIgnoredTag(yyValue) }
;

private transient String IgnoredTagGarbage =
  ( !'>' _ )*
;




// -- Ignored elements ---------------------------------------------------------

private transient WtNode IgnoredElements =
    header:IgnoredElementHeader
    {
      getState().setTagExtensionName(header.getForeign(0, String.class));
    }
    '>' body:TagBody
    {
      String content = "<" + header.getForeign(0, String.class) + header.getForeign(1, String.class) + ">" + body.getForeign(0, String.class) + body.getForeign(1, String.class);

      yyValue = setRtd(new WtIgnored(content), content);
    }
  / header:IgnoredElementHeader "/>"
    {
      String content = "<" + header.getForeign(0, String.class) + header.getForeign(1, String.class) + "/>";

      yyValue = setRtd(new WtIgnored(content), content);
    }
;

private transient WtForeignNode IgnoredElementHeader =
  name:IgnoredElementName garbage:IgnoredTagGarbage
  {
    yyValue = WtForeignNode.from(name, garbage);
  }
;

private inline String IgnoredElementName =
  yyValue:TagName &{ isIgnoredElement(yyValue) }
;




// -- Tag extensions -----------------------------------------------------------

private transient WtTagExtension TagExtension =
    header:TagHeader '>'
    {
      getState().setTagExtensionName(header.getForeign(0, String.class));
    }
    body:TagBody
    {
      yyValue = setRtd(
        new WtTagExtension(
          header.getForeign(0, String.class),
          header.getForeign(1, WtNodeList.class),
          body.getForeign(0, String.class)),
        '<', header.getForeign(0, String.class), SEP,
        header.getForeign(2, String.class), '>', body.getForeign(0, String.class), body.getForeign(1, String.class));
    }
  / header:TagHeader "/>"
    {
      yyValue = setRtd(
        new WtTagExtension(header.getForeign(0, String.class), header.getForeign(1, WtNodeList.class), null),
        '<', header.getForeign(0, String.class), SEP,
        header.getForeign(2, WtNodeList.class), "/>");
    }
;

private transient WtForeignNode TagHeader =
    name:ValidTagName &pWsPlus attributes:XmlAttributePlus ws:pWsStar
    {
      yyValue = WtForeignNode.from(name, attributes, ws);
    }
  / name:ValidTagName ws:pWsStar
    {
      yyValue = WtForeignNode.from(name, new WtNodeList(), ws);
    }
;

private transient WtForeignNode TagBody =
  content:TagContentStar
  endTag:(
    ValidClosingTag
  / Eof
    {
      yyValue = null;
    }
  )
  {
    yyValue = WtForeignNode.from(content, (String) endTag);
  }
;

private transient String TagContentStar =
  ( !ValidClosingTag _ )*
;




// -- Opening and closing names/tags -------------------------------------------

private transient String ValidClosingTag =
  "</" endTag:ClosingTagHeader &{ isValidClosingTag(endTag.getForeign(0, String.class)) }
  {
    yyValue = "</" + endTag.getForeign(0, String.class) + endTag.getForeign(1, String.class) + ">";
  }
;

private transient WtForeignNode ClosingTagHeader =
  name:TagName ws:pWsStar '>'
  {
    yyValue = WtForeignNode.from(name, ws);
  }
;

private inline String ValidTagName =
  yyValue:TagName &{ isValidExtensionTagName(yyValue) }
;

private inline String TagName = XmlName ;




// -- End of file -------------------------------------------------------------
